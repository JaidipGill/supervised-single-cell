labs(x='Year',y='SMR')+
labs(subtitle="B")
plot_tmp2<-ggplot(temporal_rape)+
geom_line(aes(x=year, y=smr_rape))+
labs(x='Year',y='SMR')+
labs(subtitle="B")
# arrange plots side-by-side
plot_desc_dowry<-grid.arrange(plot_sp1, plot_tmp1, ncol = 2)
ggsave("Desc Dowry.png",plot_desc_dowry)
plot_desc_rape<-grid.arrange(plot_sp2, plot_tmp2, ncol = 2)
ggsave("Desc Rape.png",plot_desc_rape)
#Generating adjacency matrix
carto_up_sp <- as(carto_up, "Spatial")
w.rook <- poly2nb(carto_up_sp, row.names=carto_up$ID_area, queen=FALSE)
nb2INLA("map.graph", w.rook)
g = paste(getwd(),"/map.graph",sep="")
#Renaming columns for consistency
area_crime<-rename(area_crime, total_dowry=dowry, total_rape = rape, total_e_dowry = e_dowry, total_e_rape = e_rape)
#Incidence over space
breaks =  c(0,0.25,0.5,0.75,1,1.25,1.5,1.75,2,2.25,2.5)
spatial_dowry = mutate(spatial_dowry, SMR_cat = cut(smr_dowry, breaks, include.lowest = TRUE))
# Define the number of colors you wants
colours <- brewer.pal(9, "OrRd")
# Add more colors to this palette :
colours <- colorRampPalette(colours)(10)
plot_sp1<-ggplot(spatial_dowry) +
geom_sf(aes(fill = SMR_cat), col = 'black') +
theme_bw() +
scale_fill_manual(values = colours, drop=FALSE) +
guides(fill=guide_legend(title="SMR"))+
theme(axis.ticks = element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(),
legend.position = "right",legend.key.size = unit(0.35, "cm"),
legend.text = element_text(size = 6))+
labs(subtitle="A")
spatial_rape = mutate(spatial_rape, SMR_cat = cut(smr_rape, breaks, include.lowest = TRUE))
plot_sp2<-ggplot(spatial_rape) +
geom_sf(aes(fill = SMR_cat), col = 'black') +
theme_bw() +
scale_fill_manual(values = colours, drop=FALSE) +
guides(fill=guide_legend(title="SMR"))+
theme(axis.ticks = element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(),
legend.position = "right",legend.key.size = unit(0.35, "cm"),
legend.text = element_text(size = 6))+
labs(subtitle="A")
#Incidence over time
plot_tmp1<-ggplot(temporal_dowry)+
geom_line(aes(x=year, y=smr_dowry))+
labs(x='Year',y='SMR')+
labs(subtitle="B")
plot_tmp2<-ggplot(temporal_rape)+
geom_line(aes(x=year, y=smr_rape))+
labs(x='Year',y='SMR')+
labs(subtitle="B")
# arrange plots side-by-side
plot_desc_dowry<-grid.arrange(plot_sp1, plot_tmp1, ncol = 2)
ggsave("Desc Dowry.png",plot_desc_dowry)
plot_desc_rape<-grid.arrange(plot_sp2, plot_tmp2, ncol = 2)
ggsave("Desc Rape.png",plot_desc_rape)
#Generating adjacency matrix
carto_up_sp <- as(carto_up, "Spatial")
w.rook <- poly2nb(carto_up_sp, row.names=carto_up$ID_area, queen=FALSE)
nb2INLA("map.graph", w.rook)
g = paste(getwd(),"/map.graph",sep="")
#Renaming columns for consistency
area_crime<-rename(area_crime, total_dowry=dowry, total_rape = rape, total_e_dowry = e_dowry, total_e_rape = e_rape)
library(Seurat)
library(Matrix)
library(tidyverse)
# Load the Seurat object from a file
combined_seurat <- readRDS(file = "Multiome_RNA_ATAC_Mouse_Brain/combined_seurat.rds")
print('hello')
# Subset the Seurat object
subset_seurat <- combined_seurat[,1:1000]
rm(combined_seurat)
# Visualize QC metrics as a violin plot
#mt_genes<-c('ENSMUSG00000064337','ENSMUSG00000064339','ENSMUSG00000064336','ENSMUSG00000064338','ENSMUSG00000064340','ENSMUSG00000064342','ENSMUSG00000064343','ENSMUSG00000064344','ENSMUSG00000064346','ENSMUSG00000064347','ENSMUSG00000064348','ENSMUSG00000064349','ENSMUSG00000064350','ENSMUSG00000064352','ENSMUSG00000064353','ENSMUSG00000064355','ENSMUSG00000064359','ENSMUSG00000064361','ENSMUSG00000064364','ENSMUSG00000064365','ENSMUSG00000064366','ENSMUSG00000064369','ENSMUSG00000064371','ENSMUSG00000064372')
#subset_seurat$mitoPercent<-PercentageFeatureSet(subset_seurat, features=mt_genes)
#QC
VlnPlot(subset_seurat, features = c("nFeature_RNA", "nCount_RNA","nFeature_ATAC", "nCount_ATAC", "mitoPercent"), ncol = 5)
hist(subset_seurat$nCount_RNA,breaks=200)
filtered_seurat <- subset(subset_seurat, subset = nFeature_RNA > 200 & nCount_RNA > 200 & nFeature_ATAC > 200 & nCount_ATAC > 200)
subset_seurat
filtered_seurat
VlnPlot(filtered_seurat, features = c("nFeature_RNA", "nCount_RNA","nFeature_ATAC", "nCount_ATAC", "mitoPercent"), ncol = 5)
#Normalisation - MUST REPEAT BELOW STEPS FOR BOTH RNA AND ATAC BY SWITCHING DEFAULT ASSAY
filtered_seurat <- NormalizeData(filtered_seurat, normalization.method = "LogNormalize", scale.factor = 10000)
#Variable selection
filtered_seurat <- FindVariableFeatures(filtered_seurat, selection.method = "vst", nfeatures = 2000)
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(filtered_seurat), 10)
# plot variable features with and without labels
plot1 <- VariableFeaturePlot(filtered_seurat)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
#Scalin Data
all.genes <- rownames(filtered_seurat)
filtered_seurat <- ScaleData(filtered_seurat, features = all.genes)
#PCA
filtered_seurat <- RunPCA(filtered_seurat, features = VariableFeatures(object = filtered_seurat))
VizDimLoadings(filtered_seurat, dims = 1:2, reduction = "pca")
DimPlot(filtered_seurat, reduction = "pca")
ElbowPlot(filtered_seurat) # Majority variance captured in first 7 PCs
filtered_seurat <- FindNeighbors(filtered_seurat, dims = 1:7)
filtered_seurat <- FindClusters(filtered_seurat, resolution = 0.8, verbose = FALSE)
filtered_seurat <- RunUMAP(filtered_seurat, dims = 1:7)
DimPlot(filtered_seurat, label = TRUE)
BiocManager::install("GenomeInfoDbData")
dir(.libPaths()[1], "Genome")
install.packages("rlang")
install.packages("rlang")
library(rlang)
BiocManager::install("GenomeInfoDbData")
BiocManager::install("GenomeInfoDbData")
if (!"GenomeInfoDbData" %in% installed.packages()) {
BiocManager::install("GenomeInfoDbData")
} else {
library(GenomeInfoDbData)
}
if (!"GenomeInfoDbData" %in% installed.packages()) {
BiocManager::install("GenomeInfoDbData")
} else {
library(GenomeInfoDbData)
}
if (!"GenomeInfoDbData" %in% installed.packages()) {
BiocManager::install("GenomeInfoDbData")
} else {
library(GenomeInfoDbData)
}
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData")
library(GenomeInfoDbData)
sessionInfo()
install.packages("reprex")
library(reprex)
library(reprex)
reprex({
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData")
})
library(reprex)
reprex({
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData")
})
library(reprex)
reprex({
sessionInfo()
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData")
})
BiocManager::install("GenomeInfoDbData
")"
""
BiocManager::install("GenomeInfoDbData")
BiocManager::install("GenomeInfoDbData")
install.packages("RcppArmadillo")
library(RcppArmadillo)
library(Rcpp)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
#> Warning: package 'BiocManager' was built under R version 4.2.3
#> Bioconductor version '3.16' is out-of-date; the current release version '3.17'
#>   is available with R version '4.3'; see https://bioconductor.org/install
BiocManager::install("GenomeInfoDbData")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
#> Warning: package 'BiocManager' was built under R version 4.2.3
#> Bioconductor version '3.16' is out-of-date; the current release version '3.17'
#>   is available with R version '4.3'; see https://bioconductor.org/install
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
library(reprex)
reprex({
sessionInfo()
install.packages("RcppArmadillo")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
#> Warning: package 'BiocManager' was built under R version 4.2.3
#> Bioconductor version '3.16' is out-of-date; the current release version '3.17'
#>   is available with R version '4.3'; see https://bioconductor.org/install
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
install.packages("Rcpp", verbose=TRUE)
library(Rcpp)
install.packages("geometries", verbose=TRUE)
install.packages("labelled", verbose=TRUE)
install.packages("Seurat", verbose=TRUE)
install.packages("sp", verbose=TRUE)
install.packages("sfheaders", verbose=TRUE)
install.packages("GenomeInfoDbData", verbose=TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
install.packages("terra", verbose=TRUE)
install.packages("terra", verbose=TRUE)
library(reprex)
reprex({
sessionInfo()
install.packages("Rcpp")
install.packages("terra")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
BiocManager::install(version = "3.17")
BiocManager::install()
a
BiocManager::install(version = "3.16")
reprex({
sessionInfo()
install.packages("Rcpp")
install.packages("terra")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
reprex({
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
install.packages("terra", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
library(reprex)
reprex({
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
install.packages("terra", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
install.packages("Rcpp", verbose = TRUE)
library(reprex)
reprex({
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
install.packages("terra", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
install.packages(file.choose(Downloads/terra_1.7-39.zip), repos=NULL)
install.packages(file.choose("Downloads/terra_1.7-39.zip"), repos=NULL)
library(reprex)
reprex({
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
install.packages("terra", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
})
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
sessionInfo()
install.packages("Rcpp", verbose = TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", verbose = TRUE)
BiocManager::install("GenomeInfoDbData", verbose = TRUE)
EMBEDDING = 'PCA' # Choose from: PCA, CCA, scVI (raw PCA?)
GROUND_TRUTH = 'wnnL2' # Choose from: wnnL2, wnnL1, rna [rna only for cancer data]
CELL_TYPE = 'All' # Choose from: B cells, T cells, Monoblast-Derived, All
N_COMPONENTS = 35   # Choose from: 10, 35
CL = 'RandomForestClassifier' # Choose from: RandomForestClassifier, SVC, LogisticRegression
DATA = 'pbmc' # Choose from: pbmc, cancer
for(GROUND_TRUTH in list('wnnL2')){
for (CL in list('RandomForestClassifier', 'SVC')){
SUFFIX = glue('{DATA}_{CL}_{EMBEDDING}_{GROUND_TRUTH}_{CELL_TYPE}_{N_COMPONENTS}')
# Read the CSV files
df_A_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df.csv"))
df_A_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df.csv"))
df_B_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df_rna.csv"))
df_B_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df_rna.csv"))
# Add identifying columns to each dataframe
df_A_metric1$Model <- 'RNA + ATAC'
df_A_metric1$Metric <- 'F1 Scores'
df_A_metric2$Model <- 'RNA + ATAC'
df_A_metric2$Metric <- 'PAP Scores'
df_B_metric1$Model <- 'RNA'
df_B_metric1$Metric <- 'F1 Scores'
df_B_metric2$Model <- 'RNA'
df_B_metric2$Metric <- 'PAP Scores'
#
# if(CELL_TYPE == 'B Cells') {
#   col_names <-  c('B intermediate','B naive', 'NK')
# } else if(CELL_TYPE == 'T Cells') {
#   col_names <-  c('CD4 Naive', 'CD4 TCM', 'CD4 TEM', 'CD8 Naive', 'CD8 TEM')
# } else if(CELL_TYPE == 'Monoblast-Derived') {
#   col_names <-  c('CD14 Mono', 'CD16 Mono', 'cDC2', 'pDC')
# }
# Plot Results (unnanotated) ----------------------------------------------
# Combine all dataframes
df_all <- bind_rows(df_A_metric1, df_A_metric2, df_B_metric1, df_B_metric2)
# Assuming 'df' is your data frame
second_column_index <- 1
last_two_columns_index <- ncol(df_all) - 1
# Extract column names
selected_column_names <- colnames(df_all)[(second_column_index + 1):(last_two_columns_index - 1)]
# Print the selected column names
print(selected_column_names)
# Pivot the dataframe to a long format
df_long <- df_all %>%
pivot_longer(cols = selected_column_names,
names_to = "Cell Type",
values_to = "Value")
# Separate plots for each metric
for (metric in unique(df_long$Metric)) {
# Filter data for the current metric
df_metric <- df_long %>% filter(Metric == metric)
# Plot
p <- ggplot(df_metric, aes(x = Model, y = Value, fill = Model)) +
geom_violin(position = "dodge") +
geom_boxplot(width = 0.1, position = position_dodge(0.9)) +
facet_wrap(~ `Cell Type`) +
labs(x = "Model", y = "Value", fill = "Model", title = glue("{metric} {GROUND_TRUTH} {EMBEDDING} {CL}")) +
theme_minimal()
print(p)
}
}
}
# Load necessary package
library(tidyverse)
library(ggplot2)
library(glue)
library(ggsignif)
EMBEDDING = 'PCA' # Choose from: PCA, CCA, scVI (raw PCA?)
GROUND_TRUTH = 'wnnL2' # Choose from: wnnL2, wnnL1, rna [rna only for cancer data]
CELL_TYPE = 'All' # Choose from: B cells, T cells, Monoblast-Derived, All
N_COMPONENTS = 35   # Choose from: 10, 35
CL = 'RandomForestClassifier' # Choose from: RandomForestClassifier, SVC, LogisticRegression
DATA = 'pbmc' # Choose from: pbmc, cancer
for(GROUND_TRUTH in list('wnnL2')){
for (CL in list('RandomForestClassifier', 'SVC')){
SUFFIX = glue('{DATA}_{CL}_{EMBEDDING}_{GROUND_TRUTH}_{CELL_TYPE}_{N_COMPONENTS}')
# Read the CSV files
df_A_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df.csv"))
df_A_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df.csv"))
df_B_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df_rna.csv"))
df_B_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df_rna.csv"))
# Add identifying columns to each dataframe
df_A_metric1$Model <- 'RNA + ATAC'
df_A_metric1$Metric <- 'F1 Scores'
df_A_metric2$Model <- 'RNA + ATAC'
df_A_metric2$Metric <- 'PAP Scores'
df_B_metric1$Model <- 'RNA'
df_B_metric1$Metric <- 'F1 Scores'
df_B_metric2$Model <- 'RNA'
df_B_metric2$Metric <- 'PAP Scores'
#
# if(CELL_TYPE == 'B Cells') {
#   col_names <-  c('B intermediate','B naive', 'NK')
# } else if(CELL_TYPE == 'T Cells') {
#   col_names <-  c('CD4 Naive', 'CD4 TCM', 'CD4 TEM', 'CD8 Naive', 'CD8 TEM')
# } else if(CELL_TYPE == 'Monoblast-Derived') {
#   col_names <-  c('CD14 Mono', 'CD16 Mono', 'cDC2', 'pDC')
# }
# Plot Results (unnanotated) ----------------------------------------------
# Combine all dataframes
df_all <- bind_rows(df_A_metric1, df_A_metric2, df_B_metric1, df_B_metric2)
# Assuming 'df' is your data frame
second_column_index <- 1
last_two_columns_index <- ncol(df_all) - 1
# Extract column names
selected_column_names <- colnames(df_all)[(second_column_index + 1):(last_two_columns_index - 1)]
# Print the selected column names
print(selected_column_names)
# Pivot the dataframe to a long format
df_long <- df_all %>%
pivot_longer(cols = selected_column_names,
names_to = "Cell Type",
values_to = "Value")
# Separate plots for each metric
for (metric in unique(df_long$Metric)) {
# Filter data for the current metric
df_metric <- df_long %>% filter(Metric == metric)
# Plot
p <- ggplot(df_metric, aes(x = Model, y = Value, fill = Model)) +
geom_violin(position = "dodge") +
geom_boxplot(width = 0.1, position = position_dodge(0.9)) +
facet_wrap(~ `Cell Type`) +
labs(x = "Model", y = "Value", fill = "Model", title = glue("{metric} {GROUND_TRUTH} {EMBEDDING} {CL}")) +
theme_minimal()
print(p)
}
}
}
setwd("~/GitHub/supervised-single-cell")
EMBEDDING = 'PCA' # Choose from: PCA, CCA, scVI (raw PCA?)
GROUND_TRUTH = 'wnnL2' # Choose from: wnnL2, wnnL1, rna [rna only for cancer data]
CELL_TYPE = 'All' # Choose from: B cells, T cells, Monoblast-Derived, All
N_COMPONENTS = 35   # Choose from: 10, 35
CL = 'RandomForestClassifier' # Choose from: RandomForestClassifier, SVC, LogisticRegression
DATA = 'pbmc' # Choose from: pbmc, cancer
for(GROUND_TRUTH in list('wnnL2')){
for (CL in list('RandomForestClassifier', 'SVC')){
SUFFIX = glue('{DATA}_{CL}_{EMBEDDING}_{GROUND_TRUTH}_{CELL_TYPE}_{N_COMPONENTS}')
# Read the CSV files
df_A_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df.csv"))
df_A_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df.csv"))
df_B_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df_rna.csv"))
df_B_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df_rna.csv"))
# Add identifying columns to each dataframe
df_A_metric1$Model <- 'RNA + ATAC'
df_A_metric1$Metric <- 'F1 Scores'
df_A_metric2$Model <- 'RNA + ATAC'
df_A_metric2$Metric <- 'PAP Scores'
df_B_metric1$Model <- 'RNA'
df_B_metric1$Metric <- 'F1 Scores'
df_B_metric2$Model <- 'RNA'
df_B_metric2$Metric <- 'PAP Scores'
#
# if(CELL_TYPE == 'B Cells') {
#   col_names <-  c('B intermediate','B naive', 'NK')
# } else if(CELL_TYPE == 'T Cells') {
#   col_names <-  c('CD4 Naive', 'CD4 TCM', 'CD4 TEM', 'CD8 Naive', 'CD8 TEM')
# } else if(CELL_TYPE == 'Monoblast-Derived') {
#   col_names <-  c('CD14 Mono', 'CD16 Mono', 'cDC2', 'pDC')
# }
# Plot Results (unnanotated) ----------------------------------------------
# Combine all dataframes
df_all <- bind_rows(df_A_metric1, df_A_metric2, df_B_metric1, df_B_metric2)
# Assuming 'df' is your data frame
second_column_index <- 1
last_two_columns_index <- ncol(df_all) - 1
# Extract column names
selected_column_names <- colnames(df_all)[(second_column_index + 1):(last_two_columns_index - 1)]
# Print the selected column names
print(selected_column_names)
# Pivot the dataframe to a long format
df_long <- df_all %>%
pivot_longer(cols = selected_column_names,
names_to = "Cell Type",
values_to = "Value")
# Separate plots for each metric
for (metric in unique(df_long$Metric)) {
# Filter data for the current metric
df_metric <- df_long %>% filter(Metric == metric)
# Plot
p <- ggplot(df_metric, aes(x = Model, y = Value, fill = Model)) +
geom_violin(position = "dodge") +
geom_boxplot(width = 0.1, position = position_dodge(0.9)) +
facet_wrap(~ `Cell Type`) +
labs(x = "Model", y = "Value", fill = "Model", title = glue("{metric} {GROUND_TRUTH} {EMBEDDING} {CL}")) +
theme_minimal()
print(p)
}
}
}
for(GROUND_TRUTH in list('wnnL2')){
for (CL in list('RandomForestClassifier', 'SVC')){
SUFFIX = glue('{DATA}_{CL}_{EMBEDDING}_{GROUND_TRUTH}_{CELL_TYPE}_{N_COMPONENTS}')
# Read the CSV files
df_A_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df.csv"))
df_A_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df.csv"))
df_B_metric1 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_F1_df_rna.csv"))
df_B_metric2 <- read_csv(glue("Supervised Models/Results_{SUFFIX}_PAP_df_rna.csv"))
# Add identifying columns to each dataframe
df_A_metric1$Model <- 'RNA + ATAC'
df_A_metric1$Metric <- 'F1 Scores'
df_A_metric2$Model <- 'RNA + ATAC'
df_A_metric2$Metric <- 'PAP Scores'
df_B_metric1$Model <- 'RNA'
df_B_metric1$Metric <- 'F1 Scores'
df_B_metric2$Model <- 'RNA'
df_B_metric2$Metric <- 'PAP Scores'
#
# if(CELL_TYPE == 'B Cells') {
#   col_names <-  c('B intermediate','B naive', 'NK')
# } else if(CELL_TYPE == 'T Cells') {
#   col_names <-  c('CD4 Naive', 'CD4 TCM', 'CD4 TEM', 'CD8 Naive', 'CD8 TEM')
# } else if(CELL_TYPE == 'Monoblast-Derived') {
#   col_names <-  c('CD14 Mono', 'CD16 Mono', 'cDC2', 'pDC')
# }
# Plot Results (unnanotated) ----------------------------------------------
# Combine all dataframes
df_all <- bind_rows(df_A_metric1, df_A_metric2, df_B_metric1, df_B_metric2)
# Assuming 'df' is your data frame
second_column_index <- 1
last_two_columns_index <- ncol(df_all) - 1
# Extract column names
selected_column_names <- colnames(df_all)[(second_column_index + 1):(last_two_columns_index - 1)]
# Print the selected column names
print(selected_column_names)
# Pivot the dataframe to a long format
df_long <- df_all %>%
pivot_longer(cols = selected_column_names,
names_to = "Cell Type",
values_to = "Value")
# Separate plots for each metric
for (metric in unique(df_long$Metric)) {
# Filter data for the current metric
df_metric <- df_long %>% filter(Metric == metric)
# Plot
p <- ggplot(df_metric, aes(x = Model, y = Value, fill = Model)) +
geom_violin(position = "dodge") +
geom_boxplot(width = 0.1, position = position_dodge(0.9)) +
facet_wrap(~ `Cell Type`) +
labs(x = "Model", y = "Value", fill = "Model", title = glue("{metric} {GROUND_TRUTH} {EMBEDDING} {CL}")) +
theme_minimal()
print(p)
}
}
}
